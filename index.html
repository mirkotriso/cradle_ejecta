<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Ejecta simulation - Ryugu</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <!-- <script src="./threejs/build/three.js"></script> -->
    <script type="module">

        import * as THREE from './threejs/build/three.module.js';
            import { GUI } from './threejs/examples/jsm/libs/dat.gui.module.js';
            import { OBJLoader } from './threejs/examples/jsm/loaders/OBJLoader.js';
            import { OrbitControls } from './threejs/examples/jsm/controls/OrbitControls.js';

            const bkgrndMaxRadius = 10;
            const MAX_NP = 30000;
            const COLOR = [108, 188, 213];
            const clock = new THREE.Clock();

            // Options to be added to the GUI
            var options = {
                particleCount: 2500,
                speed: 500,
                play: false,
                reset: false,
                run: function() {
                    this.play = true;
                },
                destroy: function() {
                    this.reset = true;
                }
            };

            const gui = new GUI()
            const ejectaFolder = gui.addFolder('Ejecta Simulation')
            ejectaFolder.add(options, 'particleCount').onChange(function (value) {
                if (value > MAX_NP) {
                    value = MAX_NP;
                }
                console.log(value)
                options.particleCount = value;
            }).name('Particles');
            ejectaFolder.add(options, 'run').name('Run');
            ejectaFolder.add(options, 'destroy').name('Reset');
            ejectaFolder.open();
            const controlFolder = gui.addFolder('Controls');
            controlFolder.add(options, 'speed', 100, 2000).listen().name('Sim. Speed');
            controlFolder.open();

            // asteroid orbital period
            const Ta = 473.889287;  // days
            // reflectivity coefficient
            const Cr = 0.07;
            // asteroid mean radius
            const Ra = 440;  // m
            // asteroid gravitational parameter
            const mua = 32;  // m^3 / s^2
            // sun gravitational parameter
            const mus = 1.327 * 10**20;
            // 
            const P0 = 1.02 * 10**17;
            // area to mass ratio of the particle
            const m_a = 50;  // area to mass ratio
            // lightness parameter
            const beta = (1 + Cr) * P0 / (m_a * mua**(1/3) * mus**(2/3))
            // angular velocity of the asteroid orbit
            const omega = 2 * Math.PI / (Ta * 24 * 3600); 
            // normalisation constants
            const T = 1 / omega;
            const L = (mua / omega**2)**(1/3)
            const V = L / T;

            // particle ejecta properties
            const v_esc = Math.sqrt(2 * mua / Ra);
            const v_min = v_esc / 4;

            function getInitState(options) {
                var y0 = [];
                for (var i = 0; i < options.particleCount; i++)
                {   
                    let uv = randomSpherePoint(0, 0, 0, 1);
                    let vi = randomSpeed(v_min, v_esc);
                    let vxi = vi * uv[0];
                    let vyi = vi * uv[1];
                    let vzi = vi * uv[2];
                    y0.push([0, 0, Ra, vxi, vyi, vzi]);
                }
                return y0;
            }

            var ejecta = null;
            function update(renderer, scene, camera, controls, options) {

                let delta = Math.min(0.05, clock.getDelta());
                let dh = delta * options.speed;

                var ryugu = scene.getObjectByName("ryugu", true);
                if (ryugu != undefined) {
                    ryugu.rotation.z += 1/2 * 0.01;
                }

                if (options.play == true) {
                    const state_0 = getInitState(options);
                    ejecta = new EjectaParticles('particles', state_0);
                    ejecta.addToScene(scene);
                    options.play = false;
                }

                if (ejecta != undefined) {
                    ejecta.move(dh)
                }

                if (options.reset == true) {
                    ejecta.removeFromScene(scene);
                    options.reset = false;
                }

                controls.update();
                renderer.render(scene, camera);
                requestAnimationFrame(function () {
                    update(renderer, scene, camera, controls, options);
                });
                }

            function init() {
                // Create the renderer that controls animation.
                let renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor("#121212", 1);
                // Attach the renderer to the div element.
                const container = document.createElement( 'div' );
                document.body.appendChild( container );
                container.appendChild( renderer.domElement );
                // Create the scene that holds all of the visible objects.
                let scene = new THREE.Scene();

                const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
                camera.up.set(0, 0, 1);
                camera.position.set(5, 5, 0);
                scene.add( camera );

                const ambientLight = new THREE.AmbientLight( 0xcccccc, 0.9 );
                scene.add( ambientLight );

                const light = new THREE.PointLight( 0xffffff, 3, 15 );
                light.position.set( 4, 0, 0 );
                light.castShadow = true;
                scene.add( light );
                
                // Create controls that allows a user to move the scene with a mouse.
                let controls = new OrbitControls(camera, renderer.domElement);
                controls.minDistance = 0.4;
                controls.maxDistance = bkgrndMaxRadius;
                controls.update();

                // BACKGROUND
                addGalaxy(scene);
                // RYUGU
                createAsteroid(scene);

                // Resize window
                function onWindowResize() {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize( window.innerWidth, window.innerHeight );
                }

                window.addEventListener( 'resize', onWindowResize );

            // START ANIMATION
            update(renderer, scene, camera, controls, options);
            }
            
            /** USEFUL FUNCTIONS **/

            // Texture Loader
            let textureLoader = new THREE.TextureLoader();
            let addGalaxy = function (scene) { 
            // Galaxy
            let galaxyGeometry = new THREE.SphereGeometry(bkgrndMaxRadius, 32, 32);
            let galaxyMaterial = new THREE.MeshBasicMaterial({
              side: THREE.BackSide
            });
            let galaxy = new THREE.Mesh(galaxyGeometry, galaxyMaterial);

            // Load Galaxy Textures
            textureLoader.crossOrigin = true;
            textureLoader.load(
                'https://s3-us-west-2.amazonaws.com/s.cdpn.io/141228/starfield.png',
                function(texture) {
                    galaxyMaterial.map = texture;
                    scene.add(galaxy);
                }
            );}

            let createAsteroid = function(scene) {
                // Create a material
                var textureLoader = new THREE.TextureLoader();
                var map = textureLoader.load('./img/stone_asteroid_tex.jpg');
                var material = new THREE.MeshStandardMaterial({
                    map: map,
                    flatShading: true,
                    roughness: 0.8,
                    metalness: 0.75
            });
            // instantiate a loader
            const loader = new OBJLoader();

            // load a resource
            loader.load(
                // resource URL
                './assets/model.obj',
                // called when resource is loaded
                function ( object ) {
                    object.name = 'ryugu';
                    object.castShadow = true;
                    object.receiveShadow = true;

                    // For any meshes in the model, add our material.
                    object.traverse( function ( node ) {
                        if ( node.isMesh ) node.material = material;
                    } );
                    scene.add( object );
                },
                // called when loading is in progresses
                function ( xhr ) {

                    console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

                },
                // called when loading has errors
                function ( error ) {

                    console.log( 'An error happened' );

                }
            );}

            let dynamics = function(states, beta) {

                let xdot, ydot, zdot, vxdot, vydot, vzdot;
                const r = Math.sqrt(states[0]**2 + states[1]**2 + states[2]**2);
                if (r < 0.75*Ra) {
                    xdot = 0;
                    ydot = 0;
                    zdot = 0;
                    vxdot = 0;
                    vydot = 0;
                    vzdot = 0;
                } else {
                    xdot = states[3];
                    ydot = states[4];
                    zdot = states[5];
                    vxdot = - mua * states[0] / r**3;
                    vydot = - mua * states[1] / r**3;
                    vzdot = - mua * states[2] / r**3;
                }

                return [xdot, ydot, zdot, vxdot, vydot, vzdot];}

                
                class EjectaParticles extends THREE.Points {
                constructor (name, data) {
                    super();

                    const positions = [];
                    const colors = [];
                    const size = data.length;
                    data.forEach(function (item, index) {
                        positions.push(item[0], item[1], item[2]);
                        colors.push(COLOR[0] / 255, COLOR[1] / 255, COLOR[2] / 255);
                        })

                    const geometry = new THREE.BufferGeometry();

                    geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
                    geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
                    geometry.computeBoundingSphere();
                    const sprite = new THREE.TextureLoader().load( './img/circle.png' );
                    // TODO: to change size and texture need to loop and create array of points
                    // https://stackoverflow.com/questions/53786863/points-opacity-size-within-three-js
                    const material = new THREE.PointsMaterial( { size: 0.075, map: sprite, vertexColors: true,
                        blending: THREE.AdditiveBlending, transparent: true, depthTest: true, alphaTest: 0.6} );

                    this.geometry = geometry;
                    this.material = material;
                    this.name = name;
                    this.states = [...data];
                    this.sortParticles = true;

                }

                move(dh) {

                    const positions = this.geometry.attributes.position.array;
                    // update the position here
                    var j = 0;
                    let new_states = [] 
                    this.states.forEach(function (item, index) {
                        let dy = dynamics(item, beta);
                        dy = dy.map( function (x) { return x*dh; } );
                        const pos = item.map( function(x, idx) { return x + dy[idx]; } );
                        positions[j*3] = pos[0] / Ra / 2;
                        positions[j*3+1] = pos[1] / Ra / 2;
                        positions[j*3+2] = pos[2] / Ra / 2;

                        new_states.push(pos);
                        j += 1;
                    });
                    this.states = new_states;
                    // allow the position to be updated
                    this.geometry.attributes.position.needsUpdate = true;
                    this.geometry.computeBoundingSphere();
                }

                addToScene(scene) {
                    scene.add(this);
                }

                removeFromScene(scene) {
                    var selectedObject = scene.getObjectByName(this.name);
                    this.geometry.dispose();
                    this.material.dispose();
                    scene.remove( selectedObject );       
                }

            }

            /*
            Returns a random point of a sphere, evenly distributed over the sphere.
            The sphere is centered at (x0,y0,z0) with the passed in radius.
            The returned point is returned as a three element array [x,y,z]. 
            */
            function randomSpherePoint(x0, y0, z0, radius){

                let u = Math.random();
                let v = Math.random();
                let theta = 2 * Math.PI * u;
                let phi = Math.acos(0.42 + (0.91 - 0.42)*v);
                let x = x0 + (radius * Math.sin(phi) * Math.cos(theta));
                let y = y0 + (radius * Math.sin(phi) * Math.sin(theta));
                let z = z0 + (radius * Math.cos(phi));

            return [x, y, z];
            }

            function randomSpeed(u_min, u_max) {
                return Math.random() * (u_max - u_min) + u_min;
            }

            init();

		</script>
</body>

</html>