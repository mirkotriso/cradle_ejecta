<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Ejecta simulation - Ryugu</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            min-height: 100vh;
        }

        .wrap {
            height: 100%;
        }

        .footer {
            background-color: black;
            color: white;
            position: fixed;
            bottom: 0px;
            width: 100%;
            height: 30px;
            margin-bottom: 0px;
            font-family: sans-serif;
            vertical-align: text-bottom;
            padding-bottom: 5px;
            font-size: small;
            display: flex;
            justify-content: space-between;
        }

        .footer a {
            color: #93b0d0;
        }
    </style>
</head>

<body>
    <div id="wrap">
        <script type="module">

            import * as THREE from './threejs/build/three.module.js';
        import { GUI } from './threejs/examples/jsm/libs/dat.gui.module.js';
        import { OBJLoader } from './threejs/examples/jsm/loaders/OBJLoader.js';
        import { OrbitControls } from './threejs/examples/jsm/controls/OrbitControls.js';

            const axesHelper = new THREE.AxesHelper( 3 );
            const bkgrndMaxRadius = 10;
            const reducer = (accumulator, curr) => accumulator + curr;
            const MAX_NP = 30000;
            const DP_MAX = 10;
            const DP_MIN = 0.01;
            const COLOR = [108, 188, 213];
            const clock = new THREE.Clock();

            // Options to be added to the GUI
            var options = {
                particleCount: 5000,
                dp: 1,
                toggle_srp: true,
                vej: 'C2',
                lon: 0,
                lat: 90,
                speed: 500,
                play: false,
                reset: false,
                run: function() {
                    this.play = true;
                },
                destroy: function() {
                    this.reset = true;
                }
            };

            const gui = new GUI()
            const ejectaFolder = gui.addFolder('Ejecta Simulation')
            ejectaFolder.add(options, 'particleCount').onChange(function (value) {
                if (value > MAX_NP) {
                    value = MAX_NP;
                }
                options.particleCount = value;
            }).name('Particles');
            ejectaFolder.add(options, 'dp', DP_MIN, DP_MAX).onChange().name('Diameter (mm)');
            ejectaFolder.add(options, 'vej', ['C2', 'Random']).onChange().name('Ej. Conditions');
            ejectaFolder.add(options, 'toggle_srp').onChange().name('Include SRP');
            ejectaFolder.open();
            const locFolder = gui.addFolder('Ejecta Location')
            locFolder.add(options, 'lon', 0, 360).onChange().name('Longitude (°)');
            locFolder.add(options, 'lat', 0, 90).onChange().name('Latitude (°)');
            locFolder.open();
            const controlFolder = gui.addFolder('Controls');
            controlFolder.add(options, 'run').name('Run');
            controlFolder.add(options, 'destroy').name('Reset');
            controlFolder.add(options, 'speed', 100, 2000).listen().name('Sim. Speed');
            controlFolder.open();

            // asteroid orbital period
            const Ta = 473.889287;  // days
            // reflectivity coefficient
            const Cr = 0.07;
            // asteroid mean radius
            const Ra = 440;  // m
            // asteroid gravitational parameter
            const mua = 32;  // m^3 / s^2
            // sun gravitational parameter
            const mus = 1.327 * 10**20;
            // adimensional gravitational parameter
            const mu = mua / (mus + mua);
            // asteroid density
            const rho_a = 2600;
            // 
            const P0 = 1367;
            // astronomical unit
            const AU = 1.49597870691e11;
            // speed of light
            const SOL = 2.998e8;
            // area to mass ratio of the particle
            const m_a = 50;  // area to mass ratio
            // lightness parameter
            const BETA = P0 / SOL * AU ** 2 / mus * (1 + Cr) * 3 / (2 * rho_a * options.dp / 1000);
            // angular velocity of the asteroid orbit
            const omega = 2 * Math.PI / (Ta * 24 * 3600); 
            // rotational speed
            const rot_per = 2 * Math.PI / (7.627 * 3600);
            // normalisation constants
            const T = 1 / omega;
            const L = (mus / omega**2)**(1/3)
            const V = L / T;

            // particle ejecta properties
            const v_esc = Math.sqrt(2 * mua / Ra);
            const v_min = v_esc / 4;

            function getInitState(options) {
                var beta_dyn = getBeta(options.dp)
                var l2 = get_l2(beta_dyn);
                // compute the jacobi constant
                var C2 = 2 * get_potential(l2, 0, 0, beta_dyn);

                var y0 = [];
                for (var i = 0; i < options.particleCount; i++)
                {   
                    let lon = options.lon * Math.PI / 180;
                    let lat = options.lat * Math.PI / 180;
                    let xi = Ra * Math.cos(lat) * Math.cos(lon);
                    let yi = Ra * Math.cos(lat) * Math.sin(lon);
                    let zi = Ra * Math.sin(lat);

                    let uv = randomSpherePoint(0, 0, 0, 1);
                    let v1, v2;
                    if (options.vej == 'C2') {
                        let v_c2 = Math.sqrt(2 * get_potential(xi/L, yi/L, zi/L, beta_dyn) - C2);
                        // compute the ejection velocity by slightly increasing v_c2
                        let v_ej = v_c2 + 0.05 * (v_esc / V - v_c2);
                        v1 = v_c2 * V;
                        v2 = v_ej * V;
                    } else {
                        v1 = v_min;
                        v2 = v_esc;
                    }
                    // let vi = randomSpeed(v_min, v_esc);
                    let vi = randomSpeed(v1, v2);

                    let alpha = - Math.PI / 2 + lat;
                    let beta = - Math.PI / 2 - lon;
                    let sa = Math.sin(alpha);
                    let sb = Math.sin(beta);
                    let ca = Math.cos(alpha);
                    let cb = Math.cos(beta);

                    let vtx = vi * uv[0];
                    let vty = vi * uv[1];
                    let vtz = vi * uv[2];

                    let vxi = cb * vtx + ca * sb * vty + sa * sb * vtz;
                    let vyi = - sb * vtx + ca * cb * vty + sa * cb * vtz;
                    let vzi = ca * vtz - sa * vty;

                    y0.push([xi, yi, zi, vxi, vyi, vzi]);
                }
                return y0;
            }

            var ejecta = null;
            function update(renderer, scene, camera, controls, options) {

                let delta = Math.min(0.05, clock.getDelta());
                let dh = delta * options.speed;

                var ryugu = scene.getObjectByName("ryugu", true);
                if (ryugu != undefined) {
                    ryugu.rotation.z += rot_per * dh;
                }

                if (options.play == true) {
                    const state_0 = getInitState(options);
                    ejecta = new EjectaParticles('particles', state_0, options.dp);
                    ejecta.addToScene(scene);
                    options.play = false;
                }

                if (ejecta != undefined) {
                    ejecta.move(dh)
                }

                if (options.reset == true) {
                    ejecta.removeFromScene(scene);
                    options.reset = false;
                }

                controls.update();
                renderer.render(scene, camera);
                requestAnimationFrame(function () {
                    update(renderer, scene, camera, controls, options);
                });
                }

            function init() {
                // Create the renderer that controls animation.
                let renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor("#121212", 1);
                // Attach the renderer to the div element.
                const container = document.createElement( 'div' );
                document.body.appendChild( container );
                container.appendChild( renderer.domElement );
                // Create the scene that holds all of the visible objects.
                let scene = new THREE.Scene();
                // scene.add( axesHelper );  // uncomment to get the axes

                const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 1000 );
                camera.up.set(0, 0, 1);
                camera.position.set(-2.5, -2.5, 2.5);
                scene.add( camera );

                const ambientLight = new THREE.AmbientLight( 0xcccccc, 0.9 );
                scene.add( ambientLight );

                const light = new THREE.PointLight( 0xffffff, 3, 15 );
                light.position.set( -4, 0, 0 );
                light.castShadow = true;
                scene.add( light );
                
                // Create controls that allows a user to move the scene with a mouse.
                let controls = new OrbitControls(camera, renderer.domElement);
                controls.minDistance = 0.4;
                controls.maxDistance = bkgrndMaxRadius;
                controls.update();

                // BACKGROUND
                addGalaxy(scene);
                // RYUGU
                createAsteroid(scene);

                // Resize window
                function onWindowResize() {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize( window.innerWidth, window.innerHeight );
                }

                window.addEventListener( 'resize', onWindowResize );

            // START ANIMATION
            update(renderer, scene, camera, controls, options);
            }
            
            /** USEFUL FUNCTIONS **/

            // Texture Loader
            let textureLoader = new THREE.TextureLoader();
            textureLoader.minFilter = THREE.LinearFilter;
            let addGalaxy = function (scene) { 
            // Galaxy
            let galaxyGeometry = new THREE.SphereGeometry(bkgrndMaxRadius, 32, 32);
            let galaxyMaterial = new THREE.MeshBasicMaterial({
              side: THREE.BackSide
            });
            let galaxy = new THREE.Mesh(galaxyGeometry, galaxyMaterial);

            // Load Galaxy Textures
            textureLoader.crossOrigin = true;
            textureLoader.load(
                'https://s3-us-west-2.amazonaws.com/s.cdpn.io/141228/starfield.png',
                function(texture) {
                    galaxyMaterial.map = texture;
                    scene.add(galaxy);
                }
            );}

            let createAsteroid = function(scene) {
                // Create a material
                var textureLoader = new THREE.TextureLoader();
                var map = textureLoader.load('./img/stone_asteroid_tex.jpg');
                var material = new THREE.MeshStandardMaterial({
                    map: map,
                    flatShading: true,
                    roughness: 0.8,
                    metalness: 0.75
            });
            // instantiate a loader
            const loader = new OBJLoader();

            // load a resource
            loader.load(
                // resource URL
                './assets/model.obj',
                // called when resource is loaded
                function ( object ) {
                    object.name = 'ryugu';
                    object.castShadow = true;
                    object.receiveShadow = true;

                    // For any meshes in the model, add our material.
                    object.traverse( function ( node ) {
                        if ( node.isMesh ) node.material = material;
                    } );
                    scene.add( object );
                },
                // called when loading is in progresses
                function ( xhr ) {

                    console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

                },
                // called when loading has errors
                function ( error ) {

                    console.log( 'An error happened' );

                }
            );}

            let dynamics = function(states, beta) {

                let xdot, ydot, zdot, vxdot, vydot, vzdot;
                const r = Math.sqrt(states[0]**2 + states[1]**2 + states[2]**2);
                if (r < 0.9*Ra) {
                    xdot = 0;
                    ydot = 0;
                    zdot = 0;
                    vxdot = 0;
                    vydot = 0;
                    vzdot = 0;
                } else {
                    let x, y, z, vx, vy, vz;

                    x = states[0] / L;
                    y = states[1] / L;
                    z = states[2] / L;
                    vx = states[3] / V;
                    vy = states[4] / V;
                    vz = states[5] / V;
                    // compute radii
                    let r_sp = Math.sqrt((x + 1)**2 + y**2 + z**2);
                    let r_ap = Math.sqrt(x ** 2 + y ** 2 + z ** 2);
                    // define some parameters to avoid repetitions into the equations
                    let K1 = (1 - beta) * (1 - mu) / r_sp**3;
                    let K2 = mu / r_ap**3;

                    xdot = vx * V;
                    ydot = vy * V;
                    zdot = vz * V;
                    vxdot = (2 * vy + (x + 1 - mu) - K1 * (x + 1) - K2 * x) * (V / T);
                    vydot = (- 2 * vx + y - K1 * y - K2 * y) * (V / T);
                    vzdot = (- K1 * z - K2 * z) * (V / T);
                }

                return [xdot, ydot, zdot, vxdot, vydot, vzdot];}

                function get_l2(beta) {
                    let alpha = mu / (1 - mu);
                    let x2 = 1 - mu + Math.sqrt(alpha / beta);
                    return x2 - (1 - mu);
                }

                function get_potential(x, y, z, beta) {
                    let r_sp = Math.sqrt((x + 1)**2 + y**2 + z**2);
                    let r_ap = Math.sqrt(x ** 2 + y ** 2 + z ** 2);

                    // define some parameters to avoid repetitions into the equations
                    let K1 = (1 - beta) * (1 - mu) / r_sp;
                    let K2 = mu / r_ap;

                    return 0.5 * (x**2 + y**2) + (1 - mu) * x + K1 + K2 + 0.5 * (1 - mu)**2;
                }
                
                class EjectaParticles extends THREE.Points {
                constructor (name, data, dp) {
                    super();

                    const positions = [];
                    const colors = [];
                    const size = data.length;
                    data.forEach(function (item, index) {
                        positions.push(item[0], item[1], item[2]);
                        colors.push(COLOR[0] / 255, COLOR[1] / 255, COLOR[2] / 255);
                        })

                    const geometry = new THREE.BufferGeometry();

                    geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
                    geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
                    geometry.computeBoundingSphere();
                    const sprite = new THREE.TextureLoader().load( './img/circle.png' );
                    // TODO: to change size and texture need to loop and create array of points
                    // https://stackoverflow.com/questions/53786863/points-opacity-size-within-three-js
                    let psize = 0.06 + (options.dp - DP_MIN) / (DP_MAX - DP_MIN) * (0.1 - 0.06)
                    const material = new THREE.PointsMaterial( { size: psize, map: sprite, vertexColors: true,
                        blending: THREE.AdditiveBlending, transparent: true, depthTest: true, alphaTest: 0.6} );

                    this.geometry = geometry;
                    this.material = material;
                    this.name = name;
                    this.states = [...data];
                    this.beta = getBeta(dp);
                    this.sortParticles = true;

                }

                move(dh) {

                    const positions = this.geometry.attributes.position.array;
                    // update the position here
                    var j = 0;
                    let beta_dyn = this.beta;
                    if (options.toggle_srp == false) {
                        beta_dyn = 0;
                    }
                    let new_states = [] 
                    this.states.forEach(function (item, index) {
                        let dy = dynamics(item, beta_dyn);
                        dy = dy.map( function (x) { return x*dh; } );
                        let pos = item.map( function(x, idx) { return x + dy[idx]; } );
                        if (dy.reduce(reducer) == 0) {
                            pos = [0, 0, 0];
                        }
                        positions[j*3] = pos[0] / Ra / 2;
                        positions[j*3+1] = pos[1] / Ra / 2;
                        positions[j*3+2] = pos[2] / Ra / 2;

                        new_states.push(pos);
                        j += 1;
                    });
                    this.states = new_states;
                    // allow the position to be updated
                    this.geometry.attributes.position.needsUpdate = true;
                    this.geometry.computeBoundingSphere();
                }

                addToScene(scene) {
                    scene.add(this);
                }

                removeFromScene(scene) {
                    var selectedObject = scene.getObjectByName(this.name);
                    this.geometry.dispose();
                    this.material.dispose();
                    scene.remove( selectedObject );       
                }

            }

            /*
            Returns a random point of a hemisphere, evenly distributed over the sphere.
            The sphere is centered at (x0,y0,z0) with the passed in radius.
            The returned point is returned as a three element array [x,y,z]. 
            */
            function randomSpherePoint(x0, y0, z0, radius){

                let u = Math.random();
                let v = Math.random();
                let theta = 2 * Math.PI * u;
                let phi = Math.acos(0.42 + (0.91 - 0.42)*v);
                let x = x0 + (radius * Math.sin(phi) * Math.cos(theta));
                let y = y0 + (radius * Math.sin(phi) * Math.sin(theta));
                let z = z0 + (radius * Math.cos(phi));

            return [x, y, z];}

            /**
             * Generate uniform random speed in the given interval
             * */
            function randomSpeed(u_min, u_max) {
                return Math.random() * (u_max - u_min) + u_min;
            }

            /**
             * Compute the lightness parameter.
             * dp is in mm
             * */
            function getBeta(dp) {
                return P0 / SOL * AU ** 2 / mus * (1 + Cr) * 3 / (2 * rho_a * dp / 1000);
            }

            init();

		</script>
    </div>

    <div class="footer">
        <p>Author: Mirko Trisolini | <a href="mailto:mirko.trisolini@polimi.it">mirko.trisolini@polimi.it</a> </p>
        <p style="float:right">CRADLE | <a href="www.cradle.polimi.it">www.cradle.polimi.it</a></p>
    </div>
</body>

</html>